1. Тест сортировки get /api/users
  - Делаем запрос get http://localhost:8080/api/users;
  - В цикле в 20 (дефолтное кол-во юзеров) итераций в теле ответа по ключу ['firstName'] проходим по каждому имени и добавляем его в список;
  - Сортируем этот список в обратном порядке;
  - Делаем запрос get http://localhost:8080/api/users с параметрами {'sort': (firstName, desc)};
  - В цикле в 20 итераций в теле ответа по ключу ['firstName'] проходим по каждому имени и добавляем его в список;
  - Сравниваем списки.

2. Тест длины строки firstName post /api/users
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'I', 'lastName': 'Ivanov', 
                                                                 'email': 'ivanov@test.com' , 'dayOfBirth': '2000-02-15'};
  - Обрабатываем ответ 400;
  - Делаем апдейт json {'firstName': 'Ivan'};
  - Делаем запрос post http://localhost:8080/api/users;
  - Обрабатываем ответ 201.
  
3. Тест уникальности email post /api/users
  - Делаем запрос get http://localhost:8080/api/users/1;
  - Обрабатываем тело ответа и достаем оттуда значение email (присваеваем в get_email)
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'Ivan', 'lastName': 'Ivanov', 
                                                                 'email': get_email, 'dayOfBirth': '2000-02-15'};
  - Обрабатываем ответ 400;
  - Делаем апдейт json {'firstName': 'ivanov@test.com'};
  - Делаем запрос post http://localhost:8080/api/users;
  - Обрабатываем ответ 201.
  
4. Тест валидности email post /api/users
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'Ivan', 'lastName': 'Ivanov', 
                                                                 'email': 'ivanov@test', 'dayOfBirth': '2000-02-15'};
  - Обрабатываем ответ 400;
  - Делаем апдейт json {'email': 'ivanovtest.com'};
  - Делаем запрос post http://localhost:8080/api/users;
  - Обрабатываем ответ 400;
  - Делаем апдейт json {'email': 'ivanov@test.com'};
  - Делаем запрос post http://localhost:8080/api/users;
  - Обрабатываем ответ 201.
  * Если все мейлы будут gmail можно сделать проверку .endswith(@gmail.com).
  
5. Тест автоинкриментности id post /api/users
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'Ivan', 'lastName': 'Ivanov',
                                                                 'email': 'ivanov@test.com', 'dayOfBirth': '2000-02-15'};
  - Обрабатываем тело ответа и достаем оттуда id1;
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'Ivan', 'lastName': 'Ivanov', 
                                                                 'email': 'ivanov2@test.com', 'dayOfBirth': '2000-02-15'};
  - Обрабатываем тело ответа и достаем оттуда id2;
  - Делаем проверку id: id1 + 1 == id2
    
6. Тест типа данных lastName post /api/users
  - Делаем запрос post http://localhost:8080/api/users с json = {'firstName': 'I', 'lastName': 1337, 
                                                                 'email': 'ivanov@test.com' , 'dayOfBirth': '2000-02-15'};
  - Обрабатываем ответ 400;
  - Делаем апдейт json {'lastName': 'Ivanov'};
  - Делаем запрос post http://localhost:8080/api/users;
  - Обрабатываем ответ 201;
  - Делаем проверку типа: type(json['lastName']) == str.
  
7. Тест патча данных patch /api/users
  - Делаем запрос get http://localhost:8080/api/users/1 и фиксируем имя 'John';
  - Создаем json {'firstName': 'Nick'};
  - Далем запрос patch http://localhost:8080/api/users/1 с уже созданным json;
  - Обрабатываем ответ 204;
  - Делаем запрос get http://localhost:8080/api/users/1 и фиксируем имя 'Nick'.
  
* Тест рандомности приложения
  - Запустить приложение
  - Отправить GET /api/users;
  - Обработать ответ и сравнить его с предыдущей итерацией (при первой итерации сравнения нет);
  - Высчитать уникальность (насколько текущий состав юзеров отличается от предыдущего, например: отличается на 75%); 
  - Записать уникальность в отдельный файл;
  - Сохранить ответ для сравнения с ответом следующей итерации;
  - Выйти из приложения.
После завершения цикла вывести среднее арифметическое уникальности (можно снять по 5 крайних результатов снизу и сверху) и сравнить с заранее определенным числом. 
Если результат ниже, то считаем, что генерируются не уникальные составы юзеров.
Также при расчете уникальности можно учитывать или не учитывать позицию, на которой генерируется определенный пользователь, в ответе (т.к. приложение может выдавать одних и тех же юзеров, но шафля их местами)
Уникальность сохраняется в файл для определения «аномалий», например: повторение определенного числа каждые 5 итераций.
